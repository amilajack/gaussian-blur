var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
var _aBigTriangle = require("a-big-triangle");
var _aBigTriangleDefault = _parcelHelpers.interopDefault(_aBigTriangle);
var _glShader = require("gl-shader");
var _glShaderDefault = _parcelHelpers.interopDefault(_glShader);
var _glFbo = require("gl-fbo");
var _glFboDefault = _parcelHelpers.interopDefault(_glFbo);
var _glTexture2d = require("gl-texture2d");
var _glTexture2dDefault = _parcelHelpers.interopDefault(_glTexture2d);
var _vertGlsl = require("./vert.glsl");
var _vertGlslDefault = _parcelHelpers.interopDefault(_vertGlsl);
var _fragGlsl = require("./frag.glsl");
var _fragGlslDefault = _parcelHelpers.interopDefault(_fragGlsl);
class Gaussian {
  constructor(canvas, img) {
    this.gl = canvas.getContext("webgl2");
    let width = this.gl.drawingBufferWidth;
    let height = this.gl.drawingBufferHeight;
    const texture = _glTexture2dDefault.default(this.gl, img);
    const shader = _glShaderDefault.default(this.gl, _vertGlslDefault.default, _fragGlslDefault.default);
    shader.bind();
    shader.uniforms.iResolution = [width, height, 0];
    shader.uniforms.iChannel0 = 0;
    this.fboA = _glFboDefault.default(this.gl, [width, height]);
    this.fboB = _glFboDefault.default(this.gl, [width, height]);
    // apply linear filtering to get a smooth interpolation
    const textures = [texture, this.fboA.color[0], this.fboB.color[0]];
    const setParameters = tex => {
      tex.wrapS = this.gl.REPEAT;
      tex.wrapT = this.gl.REPEAT;
      tex.minFilter = this.gl.LINEAR;
      tex.magFilter = this.gl.LINEAR;
    };
    textures.forEach(setParameters);
    this.texture = texture;
    this.shader = shader;
    window.onresize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      ({width, height} = this.gl.canvas);
      this.gl.viewport(0, 0, width, height);
      this.fboA = _glFboDefault.default(this.gl, [width, height]);
      this.fboB = _glFboDefault.default(this.gl, [width, height]);
      shader.uniforms.iResolution = [width, height, 0];
      this.gl.viewport(0, 0, canvas.width, canvas.height);
    };
  }
  draw(iterations, radiusDelta = 1) {
    let {fboA: writeBuffer, fboB: readBuffer} = this;
    const {texture, shader, gl} = this;
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    for (let i = 0; i < iterations; i += 1) {
      const radius = (iterations - i - 1) * radiusDelta;
      // draw blurred in one direction
      writeBuffer.bind();
      if (i === 0) {
        texture.bind();
      } else {
        readBuffer.color[0].bind();
      }
      shader.bind();
      shader.uniforms.flip = true;
      shader.uniforms.direction = i % 2 === 0 ? [radius, 0] : [0, radius];
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      _aBigTriangleDefault.default(gl);
      // swap buffers
      const t = writeBuffer;
      writeBuffer = readBuffer;
      readBuffer = t;
    }
    // draw last FBO to screen
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    writeBuffer.color[0].bind();
    shader.uniforms.direction = [0, 0];
    // no blur
    shader.uniforms.flip = iterations % 2 !== 0;
    _aBigTriangleDefault.default(gl);
  }
}
exports.default = Gaussian;
